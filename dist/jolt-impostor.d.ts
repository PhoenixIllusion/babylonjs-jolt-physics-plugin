import { IPhysicsEnabledObject } from '@babylonjs/core/Physics/v1/physicsImpostor';
import { OnContactCallback, OnContactValidateCallback, JoltContactSetting, OnContactValidateResponse, JoltPhysicsCollideCallbacks } from './jolt-contact';
import { Matrix, Quaternion, Vector3 } from '@babylonjs/core/Maths/math.vector';
import { TransformNode } from '@babylonjs/core/Meshes/transformNode';
import { BoundingInfo } from '@babylonjs/core/Culling/boundingInfo';
import { AbstractMesh } from '@babylonjs/core/Meshes/abstractMesh';
import { IndicesArray, Nullable } from '@babylonjs/core/types';
import { Space } from '@babylonjs/core/Maths/math.axis';
import { JoltJSPlugin } from './jolt-physics';
import Jolt from './jolt-import';
export declare class MinimalPhysicsNode extends TransformNode implements IPhysicsEnabledObject {
    private mesh;
    boundingInfo: BoundingInfo;
    constructor(name: string, extents: Vector3, mesh: AbstractMesh);
    getBoundingInfo(): BoundingInfo;
    getVerticesData(kind: string): Nullable<number[] | Float32Array>;
    getIndices?(): Nullable<IndicesArray>;
}
export declare class ThinPhysicsNode implements IPhysicsEnabledObject {
    private index;
    private mesh;
    boundingInfo: BoundingInfo;
    position: {
        thin: ThinPhysicsNode;
        copyFrom(vec: Vector3): this;
        set(x: number, y: number, z: number): this;
        _x: number;
        _y: number;
        _z: number;
        _isDirty: boolean;
        x: number;
        y: number;
        z: number;
        toString(): string;
        getClassName(): string;
        getHashCode(): number;
        asArray(): number[];
        toArray(array: import("@babylonjs/core/types").FloatArray, index?: number | undefined): any;
        fromArray(array: import("@babylonjs/core/types").FloatArray, index?: number | undefined): any;
        toQuaternion(): Quaternion;
        addInPlace(otherVector: import("@babylonjs/core/types").DeepImmutableObject<Vector3>): any;
        addInPlaceFromFloats(x: number, y: number, z: number): any;
        add(otherVector: import("@babylonjs/core/types").DeepImmutableObject<Vector3>): any;
        addToRef<T extends Vector3>(otherVector: import("@babylonjs/core/types").DeepImmutableObject<Vector3>, result: T): T;
        subtractInPlace(otherVector: import("@babylonjs/core/types").DeepImmutableObject<Vector3>): any;
        subtract(otherVector: import("@babylonjs/core/types").DeepImmutableObject<Vector3>): any;
        subtractToRef<T_1 extends Vector3>(otherVector: import("@babylonjs/core/types").DeepImmutableObject<Vector3>, result: T_1): T_1;
        subtractFromFloats(x: number, y: number, z: number): any;
        subtractFromFloatsToRef<T_2 extends Vector3>(x: number, y: number, z: number, result: T_2): T_2;
        negate(): any;
        negateInPlace(): any;
        negateToRef<T_3 extends Vector3 = Vector3>(result: T_3): T_3;
        scaleInPlace(scale: number): any;
        scale(scale: number): any;
        scaleToRef<T_4 extends Vector3>(scale: number, result: T_4): T_4;
        getNormalToRef(result: import("@babylonjs/core/types").DeepImmutableObject<Vector3>): Vector3;
        applyRotationQuaternionToRef<T_5 extends Vector3>(q: Quaternion, result: T_5): T_5;
        applyRotationQuaternionInPlace(q: Quaternion): any;
        applyRotationQuaternion(q: Quaternion): any;
        scaleAndAddToRef<T_6 extends Vector3>(scale: number, result: T_6): T_6;
        projectOnPlane<T_7 extends Vector3>(plane: import("@babylonjs/core/Maths/math.plane").Plane, origin: Vector3): T_7;
        projectOnPlaneToRef<T_8 extends Vector3>(plane: import("@babylonjs/core/Maths/math.plane").Plane, origin: Vector3, result: T_8): T_8;
        equals(otherVector: import("@babylonjs/core/types").DeepImmutableObject<Vector3>): boolean;
        equalsWithEpsilon(otherVector: import("@babylonjs/core/types").DeepImmutableObject<Vector3>, epsilon?: number | undefined): boolean;
        equalsToFloats(x: number, y: number, z: number): boolean;
        multiplyInPlace(otherVector: import("@babylonjs/core/types").DeepImmutableObject<Vector3>): any;
        multiply(otherVector: import("@babylonjs/core/types").DeepImmutableObject<Vector3>): any;
        multiplyToRef<T_9 extends Vector3>(otherVector: import("@babylonjs/core/types").DeepImmutableObject<Vector3>, result: T_9): T_9;
        multiplyByFloats(x: number, y: number, z: number): any;
        divide(otherVector: import("@babylonjs/core/types").DeepImmutableObject<Vector3>): any;
        divideToRef<T_10 extends Vector3>(otherVector: import("@babylonjs/core/types").DeepImmutableObject<Vector3>, result: T_10): T_10;
        divideInPlace(otherVector: Vector3): any;
        minimizeInPlace(other: import("@babylonjs/core/types").DeepImmutableObject<Vector3>): any;
        maximizeInPlace(other: import("@babylonjs/core/types").DeepImmutableObject<Vector3>): any;
        minimizeInPlaceFromFloats(x: number, y: number, z: number): any;
        maximizeInPlaceFromFloats(x: number, y: number, z: number): any;
        isNonUniformWithinEpsilon(epsilon: number): boolean;
        readonly isNonUniform: boolean;
        floor(): any;
        fract(): any;
        length(): number;
        lengthSquared(): number;
        readonly hasAZeroComponent: boolean;
        normalize(): any;
        reorderInPlace(order: string): any;
        rotateByQuaternionToRef<T_11 extends Vector3>(quaternion: Quaternion, result: T_11): T_11;
        rotateByQuaternionAroundPointToRef<T_12 extends Vector3>(quaternion: Quaternion, point: Vector3, result: T_12): T_12;
        cross(other: Vector3): any;
        normalizeFromLength(len: number): any;
        normalizeToNew(): any;
        normalizeToRef<T_13 extends Vector3>(reference: T_13): T_13;
        clone(): any;
        copyFromFloats(x: number, y: number, z: number): any;
        setAll(v: number): any;
        dot(otherVector: import("@babylonjs/core/types").DeepImmutableObject<any>): number;
    };
    rotationQuaternion: {
        thin: ThinPhysicsNode;
        copyFrom(quat: Quaternion): this;
        set(x: number, y: number, z: number, w: number): this;
        _x: number;
        _y: number;
        _z: number;
        _w: number;
        _isDirty: boolean;
        x: number;
        y: number;
        z: number;
        w: number;
        toString(): string;
        getClassName(): string;
        getHashCode(): number;
        asArray(): number[];
        toArray(array: import("@babylonjs/core/types").FloatArray, index?: number | undefined): Quaternion;
        equals(otherQuaternion: import("@babylonjs/core/types").DeepImmutableObject<Quaternion>): boolean;
        equalsWithEpsilon(otherQuaternion: import("@babylonjs/core/types").DeepImmutableObject<Quaternion>, epsilon?: number | undefined): boolean;
        clone(): any;
        copyFromFloats(x: number, y: number, z: number, w: number): any;
        add(other: import("@babylonjs/core/types").DeepImmutableObject<Quaternion>): any;
        addInPlace(other: import("@babylonjs/core/types").DeepImmutableObject<Quaternion>): any;
        subtract(other: Quaternion): any;
        subtractInPlace(other: import("@babylonjs/core/types").DeepImmutableObject<Quaternion>): any;
        scale(value: number): any;
        scaleToRef<T extends Quaternion>(scale: number, result: T): T;
        scaleInPlace(value: number): any;
        scaleAndAddToRef<T_1 extends Quaternion>(scale: number, result: T_1): T_1;
        multiply(q1: import("@babylonjs/core/types").DeepImmutableObject<Quaternion>): any;
        multiplyToRef<T_2 extends Quaternion>(q1: import("@babylonjs/core/types").DeepImmutableObject<Quaternion>, result: T_2): T_2;
        multiplyInPlace(q1: import("@babylonjs/core/types").DeepImmutableObject<Quaternion>): any;
        conjugateToRef<T_3 extends Quaternion>(ref: T_3): T_3;
        conjugateInPlace(): any;
        conjugate(): any;
        invert(): any;
        invertInPlace(): any;
        lengthSquared(): number;
        length(): number;
        normalize(): any;
        normalizeFromLength(len: number): any;
        normalizeToNew(): any;
        normalizeToRef<T_4 extends Quaternion>(reference: T_4): T_4;
        toEulerAngles(): Vector3;
        toEulerAnglesToRef<T_5 extends Vector3>(result: T_5): T_5;
        toRotationMatrix<T_6 extends Matrix>(result: T_6): T_6;
        fromRotationMatrix(matrix: import("@babylonjs/core/types").DeepImmutableObject<Matrix>): any;
        dot(other: import("@babylonjs/core/types").DeepImmutableObject<any>): number;
    };
    scaling: {
        thin: ThinPhysicsNode;
        set(x: number, y: number, z: number): this;
        copyFrom(vec: Vector3): this;
        _x: number;
        _y: number;
        _z: number;
        _isDirty: boolean;
        x: number;
        y: number;
        z: number;
        toString(): string;
        getClassName(): string;
        getHashCode(): number;
        asArray(): number[];
        toArray(array: import("@babylonjs/core/types").FloatArray, index?: number | undefined): any;
        fromArray(array: import("@babylonjs/core/types").FloatArray, index?: number | undefined): any;
        toQuaternion(): Quaternion;
        addInPlace(otherVector: import("@babylonjs/core/types").DeepImmutableObject<Vector3>): any;
        addInPlaceFromFloats(x: number, y: number, z: number): any;
        add(otherVector: import("@babylonjs/core/types").DeepImmutableObject<Vector3>): any;
        addToRef<T extends Vector3>(otherVector: import("@babylonjs/core/types").DeepImmutableObject<Vector3>, result: T): T;
        subtractInPlace(otherVector: import("@babylonjs/core/types").DeepImmutableObject<Vector3>): any;
        subtract(otherVector: import("@babylonjs/core/types").DeepImmutableObject<Vector3>): any;
        subtractToRef<T_1 extends Vector3>(otherVector: import("@babylonjs/core/types").DeepImmutableObject<Vector3>, result: T_1): T_1;
        subtractFromFloats(x: number, y: number, z: number): any;
        subtractFromFloatsToRef<T_2 extends Vector3>(x: number, y: number, z: number, result: T_2): T_2;
        negate(): any;
        negateInPlace(): any;
        negateToRef<T_3 extends Vector3 = Vector3>(result: T_3): T_3;
        scaleInPlace(scale: number): any;
        scale(scale: number): any;
        scaleToRef<T_4 extends Vector3>(scale: number, result: T_4): T_4;
        getNormalToRef(result: import("@babylonjs/core/types").DeepImmutableObject<Vector3>): Vector3;
        applyRotationQuaternionToRef<T_5 extends Vector3>(q: Quaternion, result: T_5): T_5;
        applyRotationQuaternionInPlace(q: Quaternion): any;
        applyRotationQuaternion(q: Quaternion): any;
        scaleAndAddToRef<T_6 extends Vector3>(scale: number, result: T_6): T_6;
        projectOnPlane<T_7 extends Vector3>(plane: import("@babylonjs/core/Maths/math.plane").Plane, origin: Vector3): T_7;
        projectOnPlaneToRef<T_8 extends Vector3>(plane: import("@babylonjs/core/Maths/math.plane").Plane, origin: Vector3, result: T_8): T_8;
        equals(otherVector: import("@babylonjs/core/types").DeepImmutableObject<Vector3>): boolean;
        equalsWithEpsilon(otherVector: import("@babylonjs/core/types").DeepImmutableObject<Vector3>, epsilon?: number | undefined): boolean;
        equalsToFloats(x: number, y: number, z: number): boolean;
        multiplyInPlace(otherVector: import("@babylonjs/core/types").DeepImmutableObject<Vector3>): any;
        multiply(otherVector: import("@babylonjs/core/types").DeepImmutableObject<Vector3>): any;
        multiplyToRef<T_9 extends Vector3>(otherVector: import("@babylonjs/core/types").DeepImmutableObject<Vector3>, result: T_9): T_9;
        multiplyByFloats(x: number, y: number, z: number): any;
        divide(otherVector: import("@babylonjs/core/types").DeepImmutableObject<Vector3>): any;
        divideToRef<T_10 extends Vector3>(otherVector: import("@babylonjs/core/types").DeepImmutableObject<Vector3>, result: T_10): T_10;
        divideInPlace(otherVector: Vector3): any;
        minimizeInPlace(other: import("@babylonjs/core/types").DeepImmutableObject<Vector3>): any;
        maximizeInPlace(other: import("@babylonjs/core/types").DeepImmutableObject<Vector3>): any;
        minimizeInPlaceFromFloats(x: number, y: number, z: number): any;
        maximizeInPlaceFromFloats(x: number, y: number, z: number): any;
        isNonUniformWithinEpsilon(epsilon: number): boolean;
        readonly isNonUniform: boolean;
        floor(): any;
        fract(): any;
        length(): number;
        lengthSquared(): number;
        readonly hasAZeroComponent: boolean;
        normalize(): any;
        reorderInPlace(order: string): any;
        rotateByQuaternionToRef<T_11 extends Vector3>(quaternion: Quaternion, result: T_11): T_11;
        rotateByQuaternionAroundPointToRef<T_12 extends Vector3>(quaternion: Quaternion, point: Vector3, result: T_12): T_12;
        cross(other: Vector3): any;
        normalizeFromLength(len: number): any;
        normalizeToNew(): any;
        normalizeToRef<T_13 extends Vector3>(reference: T_13): T_13;
        clone(): any;
        copyFromFloats(x: number, y: number, z: number): any;
        setAll(v: number): any;
        dot(otherVector: import("@babylonjs/core/types").DeepImmutableObject<any>): number;
    };
    private matrix;
    rotation?: Vector3 | undefined;
    parent?: any;
    constructor(extents: Vector3, index: number, mesh: AbstractMesh & {
        thinInstanceCount: number;
        thinInstanceGetWorldMatrices(): Matrix[];
        thinInstanceSetMatrixAt(index: number, matrix: Matrix, refresh: boolean): void;
    });
    getScene(): import("@babylonjs/core/scene").Scene;
    protected _recompose(): void;
    computeWorldMatrix(_force: boolean): Matrix;
    getAbsolutePosition(): Vector3;
    getAbsolutePivotPoint(): Vector3;
    rotate(_axis: Vector3, _amount: number, _space?: Space | undefined): TransformNode;
    translate(_axis: Vector3, _distance: number, _space?: Space | undefined): TransformNode;
    setAbsolutePosition(_absolutePosition: Vector3): TransformNode;
    getClassName(): string;
    getBoundingInfo(): BoundingInfo;
    getVerticesData(kind: string): Nullable<number[] | Float32Array>;
    getIndices?(): Nullable<IndicesArray>;
}
type ImpostorNumberParamReq = 'mass';
type ImpostorNumberParam = 'friction' | 'restitution' | 'radiusBottom' | 'radiusTop';
type ImpostorVec3Param = 'extents' | 'centerOffMass';
type ImpostorMeshParam = 'mesh';
type ImpostorBoolParam = 'frozen' | 'sensor';
type ImpostorCollisionFilterParam = 'collision';
type ImpostorHeightMapParam = 'heightMap';
interface CollisionData {
    group?: number;
    subGroup?: number;
    filter?: Jolt.GroupFilter;
}
interface HeightMapData {
    data: Float32Array;
    size: number;
    alphaFilter?: number;
    blockSize?: number;
}
declare module '@babylonjs/core/Physics/v1/physicsImpostor' {
    interface PhysicsImpostorParameters {
        frozen?: boolean;
        extents?: Vector3;
        radiusBottom?: number;
        radiusTop?: number;
        centerOffMass?: Vector3;
        mesh?: IPhysicsEnabledObject;
        collision?: CollisionData;
        heightMap?: HeightMapData;
        sensor?: boolean;
    }
    interface PhysicsImpostor {
        get joltPluginData(): JoltPluginData;
        getParam(paramName: ImpostorBoolParam): boolean | undefined;
        getParam(paramName: ImpostorNumberParamReq): number;
        getParam(paramName: ImpostorMeshParam): IPhysicsEnabledObject | undefined;
        getParam(paramName: ImpostorNumberParam): number | undefined;
        getParam(param: ImpostorVec3Param): Vector3 | undefined;
        getParam(param: ImpostorCollisionFilterParam): CollisionData | undefined;
        getParam(param: ImpostorHeightMapParam): HeightMapData | undefined;
        JoltPhysicsCallback: JoltPhysicsCollideCallbacks;
        registerOnJoltPhysicsCollide(kind: 'on-contact-add' | 'on-contact-persist', collideAgainst: PhysicsImpostor | Array<PhysicsImpostor>, func: OnContactCallback): void;
        registerOnJoltPhysicsCollide(kind: 'on-contact-validate', collideAgainst: PhysicsImpostor | Array<PhysicsImpostor>, func: OnContactValidateCallback): void;
        unregisterOnJoltPhysicsCollide(kind: 'on-contact-add' | 'on-contact-persist', collideAgainst: PhysicsImpostor | Array<PhysicsImpostor>, func: OnContactCallback): void;
        unregisterOnJoltPhysicsCollide(kind: 'on-contact-validate', collideAgainst: PhysicsImpostor | Array<PhysicsImpostor>, func: OnContactValidateCallback): void;
        onJoltCollide(kind: 'on-contact-add' | 'on-contact-persist', event: {
            body: PhysicsImpostor;
            ioSettings: JoltContactSetting;
        }): void;
        onJoltCollide(kind: 'on-contact-validate', event: {
            body: PhysicsImpostor;
        }): OnContactValidateResponse | undefined;
    }
}
export interface JoltPluginData {
    toDispose: any[];
    mass: any;
    friction: any;
    restitution: any;
    frozen: boolean;
    plugin: JoltJSPlugin;
}
export {};
